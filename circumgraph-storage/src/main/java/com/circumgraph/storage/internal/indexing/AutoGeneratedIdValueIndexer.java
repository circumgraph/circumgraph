package com.circumgraph.storage.internal.indexing;

import com.circumgraph.model.ScalarDef;
import com.circumgraph.model.SimpleValueDef;
import com.circumgraph.storage.internal.AutoGeneratedIds;
import com.circumgraph.storage.scalars.ScalarConversionException;
import com.circumgraph.storage.types.ValueIndexer;

import se.l4.silo.engine.index.search.types.SearchFieldType;

/**
 * {@link ValueIndexer} for {@link ScalarDef#ID} that indexes the id as a
 * binary values. This allows exact matching and faceting but does not support
 * range queries.
 */
public class AutoGeneratedIdValueIndexer
	implements ValueIndexer
{
	public static final AutoGeneratedIdValueIndexer INSTANCE = new AutoGeneratedIdValueIndexer();

	private static final SearchFieldType<Object> FIELD_TYPE = SearchFieldType.forBinary()
		.map(AutoGeneratedIdValueIndexer::deserializeId, AutoGeneratedIdValueIndexer::serializeId)
		.build();

	@Override
	public String getName()
	{
		return "AUTOGENERATED_ID";
	}

	@Override
	public SimpleValueDef getType()
	{
		return ScalarDef.ID;
	}

	@Override
	public SearchFieldType<Object> getSearchFieldType()
	{
		return FIELD_TYPE;
	}

	@Override
	public int hashCode()
	{
		return getClass().hashCode();
	}

	@Override
	public boolean equals(Object obj)
	{
		if(this == obj) return true;
		if(obj == null) return false;
		return getClass() == obj.getClass();
	}

	private static final byte[] serializeId(Object value)
	{
		long id;
		if(value instanceof Long l)
		{
			id = l;
		}
		else if(value instanceof String s)
		{
			id = AutoGeneratedIds.decode(s);
		}
		else
		{
			throw new ScalarConversionException("Invalid ID, got: " + value);
		}

		return new byte[] {
			(byte) id,
			(byte) (id >> 8),
			(byte) (id >> 16),
			(byte) (id >> 24),
			(byte) (id >> 32),
			(byte) (id >> 40),
			(byte) (id >> 48),
			(byte) (id >> 56)
		};
	}

	private static final Object deserializeId(byte[] data)
	{
		return ((long) data[7] << 56)
			| ((long) data[6] & 0xff) << 48
			| ((long) data[5] & 0xff) << 40
			| ((long) data[4] & 0xff) << 32
			| ((long) data[3] & 0xff) << 24
			| ((long) data[2] & 0xff) << 16
			| ((long) data[1] & 0xff) << 8
			| ((long) data[0] & 0xff);
	}
}
